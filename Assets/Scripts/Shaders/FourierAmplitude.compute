// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSInitialSpectrum
#pragma kernel CSConjugateSpectrum

#define PI 3.14159265358979
#define g 9.81
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture


int N; // number of points on side;
float Lx; // dimension;

float windSpeed;
float2 windDirection;
float A;


Texture2D<float2> GaussianNoise;
SamplerState SamplerGaussianNoise;

RWTexture2D<float4> H0k; // h0(k)
RWTexture2D<float4> H0minusk; // h0(-k)

[numthreads(16,16,1)]
void CSInitialSpectrum (uint3 id : SV_DispatchThreadID)
{
    float2 x = float2(id.xy) - float(N) / 2.0; // centres the values from 0 - N to -N/2 - N/2
    float2 k = float2(2.0 * PI * x.x / Lx, 2.0 * PI * x.y / Lx);

    float L = windSpeed * windSpeed / g; // the largest wave possible, not to be confused with Lx

    float k_mag = length(k);    // |k|
    if (k_mag < 0.000001) k_mag = 0.000001;
    float k_magSqr = k_mag * k_mag; // |k|^2

    // Ph(k)
    float phk = A
                * (exp(-1 / pow((k_mag*L), 2)) / (k_magSqr * k_magSqr))
                * pow(dot(normalize(k), normalize(windDirection)),2)
                * exp(-k_magSqr * pow(L / 2000, 2));
    // // Ph(-k)
    // float phminusk = A
    //                  * (exp(-1 / pow((k_mag*L), 2)) / (k_magSqr * k_magSqr))
    //                  * pow(dot(normalize(-k), normalize(windDirection)),2)
    //                  * exp(-k_magSqr * pow(L / 2000, 2));



    float2 h0k =  (GaussianNoise[id.xy] * clamp(sqrt(phk), -4000, 4000)) / (sqrt(2));
    // 
    H0k[id.xy] = float4(h0k, 0, 1);


    // Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
}

// get h0minusk from h0k
[numthreads(16,16,1)]
void CSConjugateSpectrum (uint3 id: SV_DispatchThreadID)
{
    float2 h0k = H0k[id.xy];
    float2 h0minusk = H0k[uint2((N - id.x) % N, (N - id.y) % N)];
    H0minusk[id.xy] = float4(h0minusk, 0, 1);
}
