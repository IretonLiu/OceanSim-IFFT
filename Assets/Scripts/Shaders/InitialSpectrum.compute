// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSInitialSpectrum
// #pragma kernel CSConjugateSpectrum

#define PI 3.1415926535897932384626433832795
#define g 9.81
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture


int N; // number of points on side;
float Lx; // dimension;

float windSpeed;
float2 windDirection;
float A;


Texture2D<float2> GaussianNoise;
SamplerState SamplerGaussianNoise;

RWTexture2D<float4> H0k; // h0(k)
RWTexture2D<float4> H0minusk; // h0(-k)
RWTexture2D<float4> H0minusk2;

[numthreads(16,16,1)]
void CSInitialSpectrum (uint3 id : SV_DispatchThreadID)
{
    float2 x = float2(id.xy) - float(N) / 2.0; // centres the values from 0 - N to -N/2 - N/2
    float2 k = float2(2.0 * PI * x.x / Lx, 2.0 * PI * x.y / Lx); // wave number 

    float L = windSpeed * windSpeed / g; // the largest wave possible, not to be confused with Lx

    float k_mag = length(k);    // |k|
    if (k_mag < 0.000001) k_mag = 0.000001;
    float k_magSqr = k_mag * k_mag; // |k|^2


    // constant terms in Ph

    float c = A * (exp(-1 / (k_magSqr*L*L)) / (k_magSqr * k_magSqr)) * exp(-k_magSqr * pow(L / 2000, 2));

    // Ph(k)
    float phk = c * pow(dot(normalize(k), normalize(windDirection)), 2);
    // // Ph(-k)
    float phminusk = c * pow(dot(normalize(-k), normalize(windDirection)), 2);


    float2 gaussianNoiseDraw = GaussianNoise[id.xy];

    float2 h0k =  (gaussianNoiseDraw * clamp(sqrt(phk), -4000, 4000)) / (sqrt(2));
    float2 h0minusk = (gaussianNoiseDraw * clamp(sqrt(phminusk), -4000, 4000)) / (sqrt(2));

    H0k[id.xy] = float4(h0k, 0, 1);
    H0minusk[id.xy] = float4(h0minusk, 0, 1);

    // float L_ = windSpeed * windSpeed / g; // the largest wave possible, not to be confused with Lx
    // float mag = length(k) ;
    // if (mag < 0.00001) mag = 0.00001;
    // float magSq = mag * mag ;
    // // s q r t (Ph( k ) ) / s q r t ( 2 )
    // float h0k = clamp( sqrt( (A / (magSq*magSq ) )
    // * pow( dot( normalize(k) , normalize(windDirection)) , 2.0 )
    // * exp( -(1.0/(magSq * L_ * L_) ) )
    // * exp(-magSq*pow(Lx/ 2000.0 , 2.0 ) ) ) / sqrt(2.0) , -4000, 4000) ;
    // // s q r t (Ph(-k ) ) / s q r t ( 2 )
    // float h0minusk = clamp( sqrt( (A/(magSq*magSq ) )
    // * pow( dot( normalize(-k) , normalize( windDirection ) ) , 2.0 )
    // * exp( -(1.0/(magSq * L_ * L_) ) )
    // * exp(-magSq*pow(Lx/ 2000.0 , 2.0 ) ) ) / sqrt( 2.0) , -4000, 4000 ) ;


    // float2 gaussianNoiseDraw = GaussianNoise[id.xy];
    // H0k[id.xy] = float4(gaussianNoiseDraw*h0k, 0, 1);
    // H0minusk[id.xy] = float4(gaussianNoiseDraw*h0minusk, 0, 1);


    // Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
}

// get h0minusk from h0k
// [numthreads(16,16,1)]
// void CSConjugateSpectrum (uint3 id: SV_DispatchThreadID)
// {
//     float2 h0k = H0k[id.xy].xy;
//     float2 h0minusk = H0k[uint2((N - id.x -1) % N, (N - id.y -1) % N)].xy;
//     H0minusk[id.xy] = float4(h0minusk, 0, 1);
// }
// not sure how this works